test_that("generate_occurrence_id creates proper format", {
  id <- generate_occurrence_id("Smith", 2020, 1)

  expect_type(id, "character")
  expect_match(id, "Smith2020-o1")
})

test_that("generate_occurrence_id handles special characters in author name", {
  id <- generate_occurrence_id("O'Brien", 2020, 1)

  expect_match(id, "OBrien2020-o1")
  expect_false(grepl("'", id))
})

test_that("generate_occurrence_id handles empty author name", {
  id <- generate_occurrence_id("", 2020, 1)

  expect_match(id, "Author2020-o1")
})

test_that("generate_occurrence_id creates unique sequential IDs", {
  id1 <- generate_occurrence_id("Smith", 2020, 1)
  id2 <- generate_occurrence_id("Smith", 2020, 2)
  id3 <- generate_occurrence_id("Smith", 2020, 10)

  expect_match(id1, "-o1$")
  expect_match(id2, "-o2$")
  expect_match(id3, "-o10$")
  expect_false(id1 == id2)
})

test_that("add_occurrence_ids adds IDs to all rows", {
  interactions <- sample_interactions()
  interactions$occurrence_id <- NULL  # Remove if present

  result <- add_occurrence_ids(interactions, "Smith", 2020)

  expect_true("occurrence_id" %in% names(result))
  expect_equal(nrow(result), nrow(interactions))
  expect_true(all(!is.na(result$occurrence_id)))
})

test_that("add_occurrence_ids creates sequential IDs", {
  interactions <- sample_interactions()

  result <- add_occurrence_ids(interactions, "Jones", 2021)

  expect_match(result$occurrence_id[1], "Jones2021-o1")
  expect_match(result$occurrence_id[2], "Jones2021-o2")
})

test_that("add_occurrence_ids handles empty dataframe", {
  empty_df <- data.frame()

  result <- add_occurrence_ids(empty_df, "Smith", 2020)

  expect_equal(nrow(result), 0)
})

test_that("estimate_tokens handles NULL input", {
  tokens <- estimate_tokens(NULL)

  expect_equal(tokens, 0)
})

test_that("estimate_tokens handles empty string", {
  tokens <- estimate_tokens("")

  expect_equal(tokens, 0)
})

test_that("estimate_tokens handles NA input", {
  tokens <- estimate_tokens(NA_character_)

  expect_equal(tokens, 0)
})

test_that("estimate_tokens estimates character input", {
  text <- "This is a test string with multiple words"
  tokens <- estimate_tokens(text)

  expect_type(tokens, "double")
  expect_true(tokens > 0)
  # Should be roughly nchar/4 rounded up
  expected <- ceiling(nchar(text) / 4)
  expect_equal(tokens, expected)
})

test_that("estimate_tokens converts non-character to JSON", {
  data <- list(field1 = "value1", field2 = "value2")
  tokens <- estimate_tokens(data)

  expect_type(tokens, "double")
  expect_true(tokens > 0)
})

test_that("estimate_tokens handles conversion failures gracefully", {
  # Create an object that might fail JSON conversion
  obj <- new.env()
  tokens <- estimate_tokens(obj)

  expect_type(tokens, "double")
  expect_true(tokens >= 0)
})

test_that("log_message outputs formatted message", {
  expect_output(
    log_message("Test message", "INFO"),
    "\\[.+\\] INFO: Test message"
  )
})

test_that("log_message handles different log levels", {
  expect_output(log_message("Warning test", "WARNING"), "WARNING")
  expect_output(log_message("Error test", "ERROR"), "ERROR")
})

test_that("process_single_document handles errors gracefully", {
  # Create temp database
  temp_db <- withr::local_tempfile(fileext = ".sqlite")
  init_ecoextract_database(temp_db)
  db_conn <- DBI::dbConnect(RSQLite::SQLite(), temp_db)
  withr::defer(DBI::dbDisconnect(db_conn))

  # Test with non-existent file - should return error status
  result <- process_single_document(
    pdf_file = "nonexistent.pdf",
    db_conn = db_conn
  )

  expect_equal(result$status, "error")
  expect_type(result$error_message, "character")
})

test_that("build_existing_records_context handles empty interactions", {
  context <- build_existing_records_context(NULL, NULL)

  expect_type(context, "character")
  expect_match(context, "No interactions")
})

test_that("build_existing_records_context handles zero-row dataframe", {
  empty_df <- data.frame()
  context <- build_existing_records_context(empty_df, NULL)

  expect_type(context, "character")
  expect_match(context, "No interactions")
})

test_that("build_existing_records_context formats interactions properly", {
  interactions <- data.frame(
    occurrence_id = "Smith2020-o1",
    bat_species_scientific_name = "Myotis lucifugus",
    bat_species_common_name = "Little Brown Bat",
    interacting_organism_scientific_name = "Eptesicus fuscus",
    interacting_organism_common_name = "Big Brown Bat",
    location = "Yellowstone",
    stringsAsFactors = FALSE
  )

  context <- build_existing_records_context(interactions, NULL)

  expect_match(context, "Smith2020-o1")
  expect_match(context, "Myotis lucifugus")
  expect_match(context, "Little Brown Bat")
  expect_match(context, "Yellowstone")
})

test_that("build_existing_records_context handles missing organism names", {
  interactions <- data.frame(
    occurrence_id = "Test-o1",
    bat_species_scientific_name = "Myotis lucifugus",
    bat_species_common_name = "Little Brown Bat",
    interacting_organism_scientific_name = NA,
    interacting_organism_common_name = "",
    location = "",
    stringsAsFactors = FALSE
  )

  context <- build_existing_records_context(interactions, NULL)

  expect_match(context, "MISSING")
})

test_that("build_existing_records_context generates fallback IDs", {
  interactions <- data.frame(
    bat_species_scientific_name = "Myotis lucifugus",
    bat_species_common_name = "Little Brown Bat",
    interacting_organism_scientific_name = "Test species",
    interacting_organism_common_name = "Test",
    location = "",
    stringsAsFactors = FALSE
  )

  context <- build_existing_records_context(interactions, NULL)

  expect_match(context, "interaction-1")
})
